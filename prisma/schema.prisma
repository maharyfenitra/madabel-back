generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// üßç Utilisateur principal
//
model User {
  id            Int                      @id @default(autoincrement())
  name          String
  email         String?                  @unique
  phone         String                   @unique
  post          String?
  // Soft delete timestamp: when set, user is considered deleted
  deletedAt     DateTime?
  password      String
  role          Role                     @default(CANDIDAT)
  avatar        String?
  createdAt     DateTime                 @default(now())

  // üîê Auth
  refreshTokens RefreshToken[]

  // üßæ Relations avec les √©valuations (via la table de jonction)
  evaluations   EvaluationParticipant[]
}

//
// üîê Token d'authentification
//
model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  expiresAt DateTime
  createdAt DateTime @default(now())
}

//
// üìä Table principale : √âvaluation
//
model Evaluation {
  id           Int                       @id @default(autoincrement())
  ref          String                    @unique
  createdAt    DateTime                  @default(now())
  deadline     DateTime
  completedAt  DateTime?
  isCompleted  Boolean                   @default(false)
  role         String?
  
  // Optional relation to a Quiz template
  quiz        Quiz?     @relation(fields: [quizId], references: [id])
  quizId      Int?
  
  // üîó Relation avec les participants (candidats et √©valuateurs)
  participants EvaluationParticipant[]

  // timestamps
  updatedAt    DateTime                  @updatedAt
}

//
// üë• Table d'association : relie les utilisateurs √† une √©valuation
//
model EvaluationParticipant {
  id             Int          @id @default(autoincrement())
  evaluation     Evaluation   @relation(fields: [evaluationId], references: [id])
  evaluationId   Int
  user           User         @relation(fields: [userId], references: [id])
  userId         Int

  // ‚úÖ Permet de diff√©rencier si la personne est "CANDIDAT" ou "EVALUATOR"
  participantRole Role

  evaluatorType   EvaluatorType?

  createdAt      DateTime     @default(now())

  // R√©ponses donn√©es par ce participant
  answers         Answer[]

  @@unique([evaluationId, userId]) // emp√™che les doublons
}

//
// üìú √ânum√©rations
//
enum Role {
  ADMIN
  EVALUATOR
  CANDIDAT
}

enum EvaluatorType {
  DIRECT_MANAGER         // Manager Direct
  DIRECT_COLLEAGUE       // Collaborateur Direct
  PEER                   // Pair/Associ√©
  OTHER                  // Autres (client/fournisseur/famille/amis/etc.)
}

// --------------------------------------------------
// Mod√®les pour stocker les questionnaires et questions
// --------------------------------------------------

/// Un questionnaire (template) contenant plusieurs questions
model Quiz {
  id          Int        @id @default(autoincrement())
  title       String
  description String?
  isActive    Boolean    @default(true)

  // Questions appartenant √† ce quiz
  questions   Question[]
  
  // Evaluations created from this quiz template
  evaluations Evaluation[]

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}

/// Question du quiz (texte, type, ordre, poids, langue...)
model Question {
  id        Int          @id @default(autoincrement())
  quiz      Quiz         @relation(fields: [quizId], references: [id])
  quizId    Int

  text      String
  type      QuestionType @default(SINGLE_CHOICE)
  order     Int          @default(0)
  weight    Float?
  language  String?      @default("fr")

  // R√©ponse correcte (utile pour correction automatique)
  // Pour les questions √† choix, on peut marquer l'option correcte via Option.isKey
  // ou r√©f√©rencer directement une option ici pour les SINGLE_CHOICE
  correctOptionId Int?
  correctOption   Option? @relation("CorrectOption", fields: [correctOptionId], references: [id])

  // Pour les questions texte/scale, on peut stocker la r√©ponse correcte ici
  correctText     String?
  correctNumeric  Float?

  // Options / choix li√©s √† la question (pour choice questions)
  options   Option[]

  // R√©ponses associ√©es √† cette question
  answers   Answer[]

  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}

/// Option (choix) pour une question
model Option {
  id         Int      @id @default(autoincrement())
  question   Question @relation(fields: [questionId], references: [id])
  questionId Int

  text       String
  // Valeur num√©rique associ√©e au choix (utile pour scoring, √©chelles...)
  value      Int?
  // Indique si c'est la r√©ponse clef (optionnel, utile pour quizzes √† correction automatique)
  isKey      Boolean? @default(false)

  createdAt  DateTime @default(now())

  // Pour savoir quelles r√©ponses ont s√©lectionn√© cette option
  selectedByAnswers Answer[]
  // Liens vers AnswerOption (multi-select)
  answerSelections  AnswerOption[]

  // Si cette option est r√©f√©renc√©e comme r√©ponse correcte par une question
  correctForQuestions Question[] @relation("CorrectOption")
}

/// Types de question support√©s
enum QuestionType {
  SINGLE_CHOICE
  MULTIPLE_CHOICE
  TEXT
  SCALE
}

// Stocke les r√©ponses des participants (r√©ponse unique / texte / valeur num√©rique)
model Answer {
  id                       Int                      @id @default(autoincrement())
  // Lien optionnel vers le participant dans le contexte d'une √©valuation
  evaluationParticipant    EvaluationParticipant?   @relation(fields: [evaluationParticipantId], references: [id], onDelete: Cascade)
  evaluationParticipantId  Int?

  // Question r√©pondue
  question                 Question                 @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId               Int

  // R√©ponse choisie (pour SINGLE_CHOICE)
  selectedOption           Option?                  @relation(fields: [selectedOptionId], references: [id], onDelete: Cascade)
  selectedOptionId         Int?

  // R√©ponse libre (TEXT)
  textAnswer               String?

  // R√©ponse num√©rique (SCALE)
  numericAnswer            Float?

  // Pour MULTIPLE_CHOICE : relation vers la table de jonction AnswerOption
  selectedOptions          AnswerOption[]

  createdAt                DateTime                 @default(now())
}

// Table de jonction pour stocker plusieurs options s√©lectionn√©es par r√©ponse
model AnswerOption {
  id        Int    @id @default(autoincrement())
  answer    Answer @relation(fields: [answerId], references: [id], onDelete: Cascade)
  answerId  Int
  option    Option @relation(fields: [optionId], references: [id], onDelete: Cascade)
  optionId  Int

  @@unique([answerId, optionId])
}